<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">dist/main/analyze.js | potts-reborn</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">dist/main/analyze.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &quot;default&quot;: mod };
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const idx_1 = __importDefault(require(&quot;idx&quot;));
const intentClassification_1 = require(&quot;./externalApis/@google/tensorflow/intentClassification&quot;);
const logger_1 = __importDefault(require(&quot;./logger&quot;));
const mongoDB_1 = require(&quot;./model/mongoDB&quot;);
const string_1 = require(&quot;./utils/string&quot;);
const CLASSIFY_CONFIDENCE_THRESHOLD = 0.9;
/**
* Return the text or document along with the intent of the message
* @param {supportedPlatform} platform
* @param {any} payload
* @param {userType} user
* @return updated user
*/
exports.default = (platform, payload, user) =&gt; __awaiter(this, void 0, void 0, function* () {
    const log = logger_1.default.info(&apos;Analyzing...&apos;, true);
    try {
        const { text, document, entity, sentiment, } = getInformationFromMessage(platform, payload);
        if (document) {
            user.entity.lastIntent = &apos;sendDocument&apos;;
            user.lastDoc = document;
        }
        else if (text) {
            user.locale = checkLang();
            user.lastText = text;
            const intent = yield findIntent(text);
            if (typeof intent === &apos;string&apos;) {
                user.entity = {
                    lastIntent: intent,
                    sentiment,
                };
            }
            else {
                user.entity = {
                    lastIntent: &apos;unknown&apos;,
                    sentiment,
                };
            }
            if (!user.text) {
                user.text = [];
            }
            const newText = new mongoDB_1.TextDB({
                orignalText: text,
                tokenizeText: string_1.tokenizeText(text),
            });
            user.text.push(newText);
            return user;
        }
    }
    catch (e) {
        return Promise.reject(e);
    }
    finally {
        log.stop(&apos;Analyzed.&apos;);
    }
});
/**
* Get the information from the message sent by user
* @param {supportedPlatform} platform
* @param {any} payload
* @return Info object
*/
const getInformationFromMessage = (platform, payload) =&gt; {
    let info = {
        text: null,
        document: null,
        entity: null,
        sentiment: &apos;neutral&apos;,
    };
    switch (platform) {
        case &apos;telegram&apos;:
            info = {
                text: payload.text || null,
                document: payload.document || payload.photo || null,
                entity: payload.document || payload.photo ? &apos;replyToDocument&apos; : null,
                sentiment: &apos;neutral&apos;,
            };
            break;
        case &apos;messenger&apos;:
            if (idx_1.default(payload, (_) =&gt; _.message.quick_reply)) {
                const Msgpayload = idx_1.default(payload, (_) =&gt; _.message.quick_reply.payload);
                if (Msgpayload === &apos;CORRECT_SERVICE&apos; || Msgpayload === &apos;INCORRECT_SERVICE&apos;) {
                    info.document = {
                        type: &apos;QUICK_REPLY&apos;,
                        value: Msgpayload,
                    };
                }
            }
            else if (idx_1.default(payload, (_) =&gt; _.message.text)) {
                info.text = payload.message.text;
                info.entity = null;
            }
            else if (idx_1.default(payload, (_) =&gt; _.message.attachments)) {
                info.entity = &apos;replyToDocument&apos;;
                switch (payload.message.attachments[0].type) {
                    case &apos;image&apos;:
                        info.document = {
                            type: &apos;image&apos;,
                        };
                        break;
                    case &apos;video&apos;:
                        info.document = {
                            type: &apos;video&apos;,
                        };
                        break;
                    case &apos;audio&apos;:
                        // message(senderId, await speechToText(payload.message.attachments[0].payload.url))
                        info.document = {
                            type: &apos;audio&apos;,
                        };
                        break;
                    case &apos;location&apos;:
                        info.document = {
                            type: &apos;location&apos;,
                            lat: idx_1.default(payload, (_) =&gt; _.message.attachments[0].payload.coordinates.lat),
                            long: idx_1.default(payload, (_) =&gt; _.message.attachments[0].payload.coordinates.long),
                        };
                        break;
                    default:
                }
            }
            break;
        default:
    }
    return info;
};
/**
* Find the intent in the text message from the convo
* @param {string} text
* @return intent of the text
*/
const findIntent = (text) =&gt; __awaiter(this, void 0, void 0, function* () {
    try {
        const result = yield intentClassification_1.predict(text);
        let { intent, confidence, } = result;
        intent = confidence &gt;= CLASSIFY_CONFIDENCE_THRESHOLD ? intent : null;
        return intent;
    }
    catch (e) {
        return Promise.reject(e);
    }
});
/**
* //TODO
*/
const checkLang = () =&gt; &apos;en&apos;;
//# sourceMappingURL=analyze.js.map</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
