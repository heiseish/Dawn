<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">dist/main/utils/string.js | potts-reborn</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">dist/main/utils/string.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &quot;default&quot;: mod };
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const natural_1 = __importDefault(require(&quot;natural&quot;));
natural_1.default.PorterStemmer.attach();
/**
 * Tokenized text and return an array of stem words
 * NOTE: Quite unreliable
 * @param {string} text
 * @return array of tokenized text
 */
const tokenizeText = (text) =&gt; text.toLowerCase().tokenizeAndStem();
exports.tokenizeText = tokenizeText;
/**
  * Right padding s with c to a total of n chars
  * @param {string} s original string
  * @param {string} c character to be padded
  * @param {number} n length
  * @return string with right side padded
  */
const padRight = (s, c, n) =&gt; {
    if (!s || !c || s.length &gt;= n) {
        return s;
    }
    const max = (n - s.length) / c.length;
    for (let i = 0; i &lt; max; i++) {
        s += c;
    }
    return s;
};
exports.padRight = padRight;
/**
  * Left padding s with c to a total of n chars
  * @param {string} s original string
  * @param {string} c character to be padded
  * @param {number} n length
  * @return a string with left side padded
  */
const padLeft = (s, c, n) =&gt; {
    if (!s || !c || s.length &gt;= n) {
        return s;
    }
    const max = (n - s.length) / c.length;
    for (let i = 0; i &lt; max; i++) {
        s = c + s;
    }
    return s;
};
exports.padLeft = padLeft;
/**
 * Remove all substrings inside a string
 * @param {string} s original string
 * @param {string} substrings substrings to be removed
 * @return a string with all substrings removed
 */
const replaceAllSubstring = (s, ...substrings) =&gt; {
    for (const substring of substrings) {
        s = replaceAll(s, substring, &apos;&apos;);
    }
    return s;
};
exports.replaceAllSubstring = replaceAllSubstring;
/**
 * Return a numeric substring from a string
 * @param {string} s original strong
 * @param {number} index index of the numeric subtring to be returned. default is 0
 * @return a string that is convertible to a number
 */
const getNumberStringFromString = (s, index) =&gt; {
    const i = index ? index : 0;
    return s.match(/\d+/)[i] ? s.match(/\d+/)[i] : s.match(/\d+/)[0] ? s.match(/\d+/)[0] : null;
};
exports.getNumberStringFromString = getNumberStringFromString;
/**
 * Generate a random string of numbers based on length given
 * @param {number} length
 * @return a random string consists of n umber
 */
const generateRandomId = (length = 10) =&gt; {
    let text = &apos;&apos;;
    const possible = &apos;0123456789&apos;;
    for (let i = 0; i &lt; length; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
};
exports.generateRandomId = generateRandomId;
/**
 * Replace all occurence of a substring in a string
 * @param {string} str
 * @param {string} find
 * @param {string} replace
 * @return a string will all `find` replaced by `replace`
 */
const replaceAll = (str, find, replace) =&gt; {
    return str.replace(new RegExp(find, &apos;g&apos;), replace);
};
exports.replaceAll = replaceAll;
//# sourceMappingURL=string.js.map</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
